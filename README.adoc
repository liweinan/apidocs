= API Docs
:toc: macro

Examples and comparison of how a REST API can be documented with different technologies.

Goals are:

* have a detailed documentation (e.g. not limited to a one-line string per field)
* don't duplicate the documentation if the same field is used for different endpoints
* appropriate documentation in the IDE (i.e. Javadoc, for programming the server and the clients)
  as well as in tools like the Swagger Editor

The examples use Quarkus as server just because it not only supports MicroProfile OpenAPI,
but it comes also with an integrated UI. But the examples should run without any code changes
in any MicroProfile compatible server.

toc::[]

== Comparison

Comparison between the examples using Code-First and Design-First approach

[cols="1,2a,2a"]
|===
|Solution|Pros|Cons

|Code-First|
* no duplication
* The generated POJOs have Javadoc
* easy introduction of user-defined keys for structured documentation
|
* no specific IDE integration for the generation yet (what works best is `mvn compile` or `mvn generate-sources`)

|OpenAPI/constants|
* Easy Usage
|
* No Javadoc
* The annotations are duplicated (though not the texts)

|===

== Code-First

Example using OpenAPI 3 (The MicroProfile implementation, though Swagger would need almost no changes;
there are only small differences to the Swagger OpenAPI, e.g. there is no `responses` in the MicroProfile `@Operation`
or `@APIResponse` with MicroProfile vs. `@ApiResponse` with Swagger).

To avoid boilerplate code, https://projectlombok.org[Lombok] ist used

=== Workflow

* The OpenAPI implementation generates YAML and/or JSON output (e.g. `openapi.yaml`) out of the annotated Java classes
* A GUI tool like the Swagger Editor allows to browse the interface visually

=== Links

* https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc#operation[MicroProfile OpenAPI Spec]
** https://github.com/eclipse/microprofile-open-api/wiki/Annotation-Samples[Annotation Examples]
** https://github.com/eclipse/microprofile-open-api/wiki/Static-File-Samples[YAML Output Examples]
* https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md[(Swagger) OpenAPI Spec]

=== Demo

Launch the example with Quarkus (`mvn compile quarkus:dev`)
and browse the interface on http://localhost:8080/swagger-ui/[http://localhost:8080/swagger-ui/]

You can also use the https://editor.swagger.io[Swagger Online Editor]
and open this URL:

* https://raw.githubusercontent.com/pe-st/apidocs/master/code-first-openapi-microprofile/doc/openapi.yaml

=== Details

To document the objects and properties of a JSON REST payload, the `@Schema` annotation is enough.

To avoid duplication of the `@Schema` annotation between different endpoints,
String constants are used.

==== Solution with Constants

Many developers prefer a compromise between simplicity and duplication avoidance.
By using constants in the OpenAPI annotations a simpler class definition is possible
at the price of duplicating the annotations, but not their content:

[source,java]
----
import static xxx.PIN_BLOCK;
import static xxx.UUID;

@Schema(description = "Request for checking a PIN")
public class PinCheckRequest {

    @Schema(description = UUID)
    private String uuid;

    @Schema(description = PIN_BLOCK)
    private String pinBlock;
}
----

This allows maintaining the documentation for a field (e.g the `pinBlock field) for any endpoint in a central location.

