= OpenAPI - code first or design first?

image:https://travis-ci.org/pe-st/apidocs.svg?branch=master["Build Status", link="https://travis-ci.org/pe-st/apidocs"]

== Overview

Let's say that you're given the task of writing a microservice *AND* providing a documentation
in OpenAPI format. You already know that there are two main approaches:

* design-first : write the OpenAPI document (a.k.a. the `openapi.yaml` file) and then generate the code
* code-first : write the code, using OpenAPI annotations, and then generate the OpenAPI document

This repository contains different implementations of a simple service to demonstrate differences
between the design-first and code-first approach.

Accompanying presentation at https://www.eclipsecon.org/europe2019[eclipsecon Europe 2019] :
https://www.eclipsecon.org/europe2019/sessions/microprofile-openapi-code-first-or-design-first[MicroProfile OpenAPI - code first or design first?]

The examples use https://quarkus.io/[Quarkus] and https://openliberty.io/[OpenLiberty] as servers
just because they not only support MicroProfile OpenAPI, but come also with an integrated UI.
But the examples should run with very few code changes in any MicroProfile compatible server.

=== Code First

* link:code-first-openapi-openliberty/README.md[code-first with OpenLiberty server and MicroProfile OpenAPI]
* link:code-first-openapi-quarkus/README.md[code-first with Quarkus server and MicroProfile OpenAPI]
* link:code-first-swagger/README.md[code-first with Swagger scanner running with Quarkus server]

=== Design First

* link:design-first-openapi-generator/README.md[design-first with OpenAPI Generator and Quarkus server]
* link:design-first-swagger-codegen/README.md[design-first with Swagger Codegen and Quarkus server]



== Comparison

Comparison between the examples using code-first and design-first approach

[cols="1,2a,2a"]
|===
|Solution|Pros|Cons

|code-first|
* No need to learn OpenAPI Documents
* Project can just be opened in the IDE (No need to generate code first)
|
* Portability: not every scanner creates the same `openapi.yaml`
* Portability: minor differences between Swagger and MicroProfile annotations
* Boilerplate and code duplication

|design-first|
* One source of truth:
Code, Documentation and Annotations generated from the same information
* can generate also Bean Validation annotations and Javadoc
|
* Learning Effort
* IDE integration not optimal yet

|===

== Links

* https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc#operation[MicroProfile OpenAPI Specification]
** https://github.com/eclipse/microprofile-open-api/wiki/Annotation-Samples[Annotation Examples]
** https://github.com/eclipse/microprofile-open-api/wiki/Static-File-Samples[YAML Output Examples]
* OpenAPI Specification
** https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md[OpenAPI Specification (OpenAPI Initiative)]
** https://swagger.io/specification/[OpenAPI Specification (Swagger)]
* https://quarkus.io/guides/openapi-swaggerui-guide[Quarkus - Using OpenAPI and Swagger UI]
* https://openliberty.io/guides/microprofile-openapi.html[OpenLiberty Guide - Documenting RESTful APIs]
